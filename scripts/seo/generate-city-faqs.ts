/**
 * Generate FAQ Content for City Pages using GPT-4
 *
 * Generates 5 SEO-optimized FAQs per city for FAQPage schema markup.
 * Targets featured snippets for queries like "how much do tattoos cost in [city]"
 */

import OpenAI from 'openai';
import * as dotenv from 'dotenv';
import * as path from 'path';
import * as fs from 'fs/promises';
import { CITIES } from '../../lib/constants/cities';

dotenv.config({ path: path.join(__dirname, '../../.env.local') });

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface CityFAQ {
  citySlug: string;
  faqs: { question: string; answer: string }[];
}

const SYSTEM_PROMPT = `You are an expert tattoo industry writer creating FAQ content for city tattoo pages. Your answers should be:

1. **Accurate & Helpful**: Provide genuinely useful information
2. **Location-Specific**: Reference the city when relevant, include local context
3. **Concise**: 2-3 sentences per answer, around 50-80 words
4. **SEO-Optimized**: Naturally incorporate city name and tattoo keywords
5. **Actionable**: Give practical advice people can use

TONE: Professional, friendly, informative. Avoid generic filler content.

FORMAT: Each answer should be a single paragraph, no bullet points or lists.`;

const FAQ_QUESTIONS = [
  'How much do tattoos cost in {city}?',
  'How do I find the best tattoo artist in {city}?',
  'What tattoo styles are popular in {city}?',
  'How do I book a tattoo appointment in {city}?',
  'What should I know before getting a tattoo in {city}?',
];

async function generateCityFAQs(
  cityName: string,
  citySlug: string,
  state: string
): Promise<CityFAQ> {
  console.log(`\nüìù Generating FAQs for ${cityName}, ${state}...`);

  const questions = FAQ_QUESTIONS.map(q => q.replace('{city}', cityName));

  const prompt = `Generate FAQ answers for ${cityName}, ${state}'s tattoo scene.

QUESTIONS TO ANSWER:
${questions.map((q, i) => `${i + 1}. ${q}`).join('\n')}

CITY CONTEXT:
- City: ${cityName}, ${state}
- Consider local cost of living, tattoo culture, booking norms

OUTPUT FORMAT (JSON):
{
  "faqs": [
    {
      "question": "${questions[0]}",
      "answer": "Answer here (50-80 words, reference ${cityName} specifically)"
    },
    {
      "question": "${questions[1]}",
      "answer": "Answer here"
    },
    {
      "question": "${questions[2]}",
      "answer": "Answer here"
    },
    {
      "question": "${questions[3]}",
      "answer": "Answer here"
    },
    {
      "question": "${questions[4]}",
      "answer": "Answer here"
    }
  ]
}

Make answers specific to ${cityName}. Reference local characteristics when possible.`;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4.1-mini',
      messages: [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user', content: prompt }
      ],
      temperature: 0.7,
      response_format: { type: 'json_object' },
    });

    const content = JSON.parse(response.choices[0].message.content || '{}');

    if (!content.faqs || content.faqs.length !== 5) {
      console.error(`   ‚ùå Invalid response structure for ${cityName}`);
      throw new Error(`Invalid GPT response structure for ${cityName}`);
    }

    console.log(`   ‚úÖ Generated ${content.faqs.length} FAQs`);

    return {
      citySlug,
      faqs: content.faqs,
    };
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`   ‚ùå Error generating FAQs: ${errorMessage}`);
    throw error;
  }
}

function formatAsTypeScript(faqData: CityFAQ[]): string {
  const formatted = faqData.map(city => {
    const faqs = city.faqs.map(faq => {
      const question = faq.question.replace(/"/g, '\\"');
      const answer = faq.answer.replace(/"/g, '\\"');
      return `      { question: "${question}", answer: "${answer}" }`;
    }).join(',\n');

    return `  '${city.citySlug}': [
${faqs}
  ]`;
  });

  return `import type { FAQ } from '../types'

/**
 * City FAQ content for FAQPage schema
 * Generated by scripts/seo/generate-city-faqs.ts
 *
 * Usage:
 * import { CITY_FAQS, getCityFAQs } from '@/lib/content/editorial/city-faqs'
 */

export const CITY_FAQS: Record<string, FAQ[]> = {
${formatted.join(',\n')}
}

/**
 * Get FAQs for a specific city
 */
export function getCityFAQs(citySlug: string): FAQ[] | undefined {
  return CITY_FAQS[citySlug]
}
`;
}

async function main() {
  // Parse CLI args
  const args = process.argv.slice(2);
  const limitIndex = args.indexOf('--limit');
  const limit = limitIndex !== -1 ? parseInt(args[limitIndex + 1], 10) : Infinity;
  const dryRun = args.includes('--dry-run');

  console.log('üöÄ City FAQ Generator (GPT-4.1-mini)\n');
  console.log('='.repeat(60));
  if (limit !== Infinity) console.log(`Limit: ${limit} cities`);
  if (dryRun) console.log('DRY RUN - no files will be written');

  // Check for existing FAQs file
  const faqsFilePath = path.join(__dirname, '../../lib/content/editorial/city-faqs.ts');
  let existingCities = new Set<string>();

  try {
    const existingContent = await fs.readFile(faqsFilePath, 'utf-8');
    // Extract existing city slugs
    const matches = existingContent.matchAll(/'([a-z-]+)':\s*\[/g);
    for (const match of matches) {
      existingCities.add(match[1]);
    }
    console.log(`Found ${existingCities.size} cities with existing FAQs`);
  } catch {
    console.log('No existing FAQs file found, creating new one');
  }

  // Get cities that need FAQs (apply limit)
  const citiesToGenerate = CITIES
    .filter(city => !existingCities.has(city.slug))
    .slice(0, limit)
    .map(city => ({
      name: city.name,
      slug: city.slug,
      state: city.state,
    }));

  if (citiesToGenerate.length === 0) {
    console.log('\n‚úÖ All cities already have FAQs!');
    return;
  }

  console.log(`\nGenerating FAQs for ${citiesToGenerate.length} cities...\n`);

  const generatedFAQs: CityFAQ[] = [];

  // Generate in batches of 50 (parallel)
  const BATCH_SIZE = 50;
  for (let i = 0; i < citiesToGenerate.length; i += BATCH_SIZE) {
    const batch = citiesToGenerate.slice(i, i + BATCH_SIZE);

    console.log(`\nüì¶ Batch ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(citiesToGenerate.length / BATCH_SIZE)}`);

    const batchResults = await Promise.allSettled(
      batch.map(city =>
        generateCityFAQs(city.name, city.slug, city.state)
      )
    );

    batchResults.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        generatedFAQs.push(result.value);
      } else {
        console.error(`   ‚ùå Failed for ${batch[index].name}: ${result.reason.message}`);
      }
    });

    // Rate limit between batches
    if (i + BATCH_SIZE < citiesToGenerate.length) {
      console.log('\n   ‚è≥ Waiting 1 second...');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  // Format and write to file
  console.log('\n\nüìù Writing TypeScript file...');
  const tsContent = formatAsTypeScript(generatedFAQs);
  await fs.writeFile(faqsFilePath, tsContent, 'utf-8');

  console.log('\n‚úÖ FAQ generation complete!');
  console.log(`   Successfully generated: ${generatedFAQs.length}/${citiesToGenerate.length} cities`);
  console.log(`   Output: lib/content/editorial/city-faqs.ts`);
  console.log(`\nEstimated cost: ~$${(generatedFAQs.length * 0.0002).toFixed(3)} (GPT-4.1-mini @ ~$0.0002/city)`);
}

main().catch(console.error);
